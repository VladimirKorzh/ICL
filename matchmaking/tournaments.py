from matchmaking.models import Player, Tournament, TournamentTeam, PlayerParticipant, Match

from datetime import datetime, timedelta
import random
from itertools import izip_longest


# neat snippet for coupling of elements
def grouper(iterable, n, fillvalue=None):
    # Collect data into fixed-length chunks or blocks
    # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx
    
    args = [iter(iterable)] * n
    return izip_longest(fillvalue=fillvalue, *args)
    

    
    
    
def db_refresh_hero_list():
    vapi = ValveApiWrapper.ValveApi()
    hero_list = vapi.get_hero_list()
    
    for each in hero_list:
      hero = Hero()
      hero.name = each
      hero.save()
    
def db_create_match_info():
    matchinfo = MatchInfo()
    matchinfo.sideapass = randint(1000, 9999)
    matchinfo.sidebpass = randint(1000, 9999)
    matchinfo.lobbypass = "ICL" + str(randint(1000, 9999))
    matchinfo.save()
    return matchinfo    
        
def db_create_player(steamid):
    player = Player()
    inv = PlayerInventory()
    inv.save()
    rating = PlayerRating()
    rating.save()
    player.inventory = inv
    player.rating    = rating 
    player.uid = steamid
    player.save()    
    return player
    
def db_refresh_player_rating(steamid):
    vapi = ValveApiWrapper.ValveApi()
    player_obj    = Player.objects.get(uid=steamid)
    player_rating = player_obj.rating    
    
    playerstats = vapi.get_player_exp_from_steamid(steamid)  
    
    player_obj.nickname       = playerstats['nickname']    
    player_rating.skillrating = playerstats['exp']
    player_rating.normal      = playerstats['exp_n_games']
    player_rating.high        = playerstats['exp_h_games']
    player_rating.veryhigh    = playerstats['exp_vh_games']
    player_rating.month_games = playerstats['total_games']    
    player_rating.extra_pts   = playerstats['extra_exp_pts']     
    player_rating.save()
    player_obj.save()
    
    return playerstats
    
    
    
    
    
    
    
def action_refresh_user_stats(steamid):
    # user wants to know his friends skill level
    # or skill of any user that has never been to ICL
    # it automatically registers user in Database    
        
    # check if player is on ICL already.    
    try: 
        player = Player.objects.get(uid=steamid)
    except Player.DoesNotExist:
        player = db_create_player(steamid)

    # Ratings could only be updated once a day
    if player.inventory.last_updated <= datetime.now()-timedelta(days=1):
       db_refresh_player_rating(steamid)

    

    
    

def action_create_1v1_match(sidea_id, sideb_id):
    # user creates a match to face his opponent with bets    
    # in the ui he\she selects the team\player for both sides
    # and this way creates an official match invitation  
    match = Match1v1()  
    match.sidea = Player.objects.get(id__exact=sidea_id)
    match.sideb = Player.objects.get(id__exact=sideb_id)
    match.info  = db_create_match_info()
    
def action_accept_1v1match_conditions(match_id, player_id):
    # both users see the terms and conditions of proposed
    # match and click Agree button.

   
   
   
   
   
   
        
        
        
def db_create_match(type, sidea_id, sideb_id, description, tournament_id=0, roundnum=0):
    match = Match()
    
    match.type = type
    
    if tournament_id != 0:
        match.tournament = Tournament.objects.get(id__exact=tournament_id)
        
    if roundnum != 0:
        match.round = roundnum

    if sidea_id and sideb_id:
        if type == 5:
            match.ttsidea = TournamentTeam.objects.get(id__exact=sidea_id)
            match.ttsideb = TournamentTeam.objects.get(id__exact=sideb_id)
        if type == 1:
            match.ppsidea = PlayerParticipant.objects.get(id__exact=sidea_id)
            match.ppsideb = PlayerParticipant.objects.get(id__exact=sideb_id)      

    if description != "":
        match.description = description

    match.sideapass = randint(1000, 9999)
    match.sidebpass = randint(1000, 9999)
    match.lobbypass = "ICL" + str(randint(1000, 9999))        
        
    match.save()
    return match.id    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
def db_create_matches_for_round(tournament_id, roundnum, winnerlist):
    amount_of_seeds = len(winnerlist)
    
    # shuffle the list
    random.shuffle(winnerlist)
    
    for each in grouper(winnerlist, 2, 0):
      db_create_match(tournament_id, roundnum, each[0], each[1], 'Autogenerated match')
      
def db_create_player_participant(player_id, tournament_id):  
    tt = TournamentTeam()
    tt.save()
  
    pp = PlayerParticipant()
    pp.player = Player.objects.get(id__exact=player_id)
    pp.tournament = Tournament.objects.get(id__exact=tournament_id)
    pp.team = tt
    pp.save()
    

    
    
  
  
  
  
  
def db_create_playerbet(player_id, match_id, common, uncommon, rare):
    player = Player.objects.get(id__exact=player_id)
    match  = Match.objects.get(id__exact=match_id)
    inv = Inventory.objects.get(id__exact=player.inventory.id)
    
    # one can only bet on matches that hasn't started yet
    if match.started == True:
        return
    
    if inv.common >= common and inv.uncommon >= uncommon and inv.rare >= rare:    
        inv.common -= common
        inv.uncommon -= uncommon
        inv.rare -= rare        
        pb = PlayerBet()
        pb.player = player
        pb.match  = match
        pb.common = common
        pb.uncommon = uncommon
        pb.rare = rare
        pb.save()
        inv.save()
    
    return pb.id
     
def db_cancel_playerbet(player_id, match_id):
    player = Player.objects.get(id__exact=player_id)
    match  = Match.objects.get(id__exact=match_id)
    inv    = Inventory.objects.get(id__exact=player.inventory.id)  
    
    pb = PlayerBet(player__exact=player, match__exact=match)
    
    inv.common += pb.common
    inv.uncommon += pb.uncommon
    inv.rare += pb.rare
    inv.save()
    
    i = pb.id
    pb.delete()
    
    return i
